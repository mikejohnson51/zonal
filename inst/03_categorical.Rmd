---
title: "Categorical Data"
description: "This vignette covers the use of zonal with categorical data"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Categorical Data}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---


```{r, include = FALSE}
knitr::opts_chunk$set(
  out.width = "100%",
  fig.width = 7, 
  fig.height = 4, dpi = 150, fig.path = "c-",
  message = FALSE, warning = FALSE, error = FALSE
)
```

```{r setup}
library(zonal)
library(ggplot2)
library(dplyr)
library(sf)
```

In `zonal` categorical data is handled with `execute_zonal_cat` which computes the relative proportion of a numeric class in each aggregation unit. In the following we illustrate its use using a mosaiced 1km grid containing MODIS 2019 land cover.

### Grid
```{r}
file = '/Users/mjohnson/github/zonal/depreciate/2019-01-01.tif'
(r = terra::rast(file))
```

Looking at the grid we can see in consists of `r raster::ncell(r)` grid cells each with a `r raster::res(r)[1]` meter by `r raster::res(r)[2]` meter resolution. Additionally, there are `r length(unique(raster::values(r)))` unique values in the grid (17 landcover and one nodata value).

### Example 1: Basic Use

First, we want to identify the percent of each land cover within each county in the USA Northeast. Doing this follows the same process as all `zonal` workflows and requires (1) identifiying the aggregation units, (2) building a weight grid and (3) running the intersection.

#### Define aggreation units

```{r AOI-NE}
AOI  = AOI::aoi_get(state = "Northeast", county = "all")
plot(AOI$geometry, main = paste(nrow(AOI), "counties"))
```

#### Build a weight grid and execute intersection

```{r}
system.time({
  lc = execute_zonal_cat(file, geom = AOI, "geoid")
})

glimpse(lc)
```
#### Exploring the data

```{r NE-forest}
to_plot = lc %>% 
  tidyr::pivot_wider(names_from = value, values_from = percentage) %>% 
  right_join(AOI) %>% 
  st_as_sf()
```

```{r NE-urban}
plot(to_plot['12'], main = "Croplands")
plot(to_plot['13'], main = "Urban")
```

### Example 2: Definining Classes 

While the above works, callinging on fields by there numeric ID is prone to error. Instead, this example shows how a reclassification table can be supplied to modify the column headings of the output table.

#### Define Aggregation Units

```{r AOI-NC}
AOI  = AOI::aoi_get(state = "North Central", county = "all")
plot(AOI$geometry, main = paste(nrow(AOI), "counties"))
```
#### Define Reclass Table

A reclassification table tells us what each numeric value represents in a categorical raster. Below, we use a CSV file to define this mapping. The schema used is that one column must be named "from" - this is the exisiting data values, and one column must be named "to" - this is the desired column headings.

```{r}
rcl = read.csv("../inst/modis_lc.csv") %>% 
  dplyr::select(from = Class, to = short)

head(rcl)
```

#### Build a weight grid and execute intersection

```{r}
system.time({
  lc = execute_zonal_cat(file, geom = AOI, ID = "geoid", rcl = rcl)
})

glimpse(lc)
```

#### Explore the data

```{r NC-crops}
midwest = merge(AOI, lc)
plot(filter(midwest, value == 'croplands')['percentage'], main = "Croplands")
```

```{r, NC-urban}
plot(filter(midwest, value == 'urban')['percentage'], main = "Urban")
```

### Further user-based aggregates

In the MODIS land cover scheme there are 5 classes loosly representing forest. If wanted to aggregate these to a single forest class, we can use the output `zonal` table.

```{r NC-forest}
forest = filter(lc, grepl('forest|broad|needle', value)) %>% 
  group_by(geoid) %>% 
  summarise(forest = sum(percentage)) %>% 
  right_join(AOI) %>% 
  sf::st_as_sf()

plot(forest['forest'], main = "Forest")
```


## Comapre with exactextractr

From the `exactectractr` vignettes there is an example to compute class statisitcs using `dplyr`. Here we compare that appraoch, to one supplimented with `data.table`, to `zonal` with pre-compted weights, and to a single `zonal` execution.

```{r exactextract-comp, message = FALSE, warning=FALSE}
library(raster)
library(exactextractr)
library(data.table)

# exactextract with dplyr
exactextract_dplyr = function(file, AOI) {
  exact_extract(raster(file), AOI, function(df) {
  df %>%
    mutate(frac_total = coverage_fraction / sum(coverage_fraction)) %>%
    group_by(geoid, value) %>%
    summarise(freq = sum(frac_total), .groups = "keep")
}, summarize_df = TRUE, include_cols = "geoid", progress = FALSE)
}

# exactextract with data.table
exactextract_dt = function(file, AOI){
  exact_extract(raster(file), AOI, function(df) {
    dt = setDT(df)
    dt$frac_total = dt$coverage_fraction / sum(dt$coverage_fraction)
    dt[, .(freq = sum(frac_total, na.rm = TRUE)), by = .(value)]
  }, summarize_df = TRUE, include_cols = "geoid", progress = FALSE)
}

# pre-compute weights 
w = weighting_grid(file, AOI, "name")

bnch <- bench::mark(
  iterations = 1, check = FALSE, time_unit = "s",
  exactextract_dplyr_out  = exactextract_dplyr(file, AOI),
  exactextract_dt_out     = exactextract_dt(file, AOI),
  zonal_full              = execute_zonal_cat(file, AOI, "geoid"),
  zonal_stage_weights     = execute_zonal_cat(file, w = w)
)
```

```{r, echo = FALSE}
oo = bnch %>%
  dplyr::select(exp = expression, medianTime = median, memoryAllocated = mem_alloc) %>% 
  mutate(exp = names(exp), memoryAllocated = unclass(memoryAllocated)/1e9) %>% 
  tidyr::pivot_longer(-exp) %>% 
  mutate(labs = case_when(name == 'medianTime' ~ "1. Median Time\n(seconds)",
                          name == 'memoryAllocated' ~ "3. Memory\n(GB)",
                          name == "TotalTime" ~ "2. Total Time (precompute weights)\n(sec)"))

ggplot(data = oo) +
  aes(x = exp, y = value) + 
  geom_col(aes(fill = exp)) +
  facet_wrap(~labs, scales = "free_y") + 
  theme_bw() + 
  labs(y = "", x = "", title = "HUC01 Test Case") + 
  theme(legend.position = "bottom") + 
   theme(axis.title.x=element_blank(),
        axis.text.x=element_blank())


```
